<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single Wall with 45° Cut Demo (Corrected)</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: sans-serif; }
        canvas { display: block; }
        .info, .controls {
            position: absolute;
            left: 10px;
            color: #fff;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
            z-index: 10;
        }
        .info { top: 10px; }
        .controls { bottom: 10px; font-size: 12px; }
    </style>
</head>
<body>
    <div class="info">
        <h3>Single Wall with Square End</h3>
        <p><strong>Wall:</strong> 3000mm × 150mm × 2500mm</p>
        <p><strong>Right End:</strong> Square end</p>
        <p><strong>Press SPACE:</strong> Toggle 45° cut</p>
    </div>

    <div class="controls">
        <p><strong>Controls:</strong></p>
        <p>• Left Mouse: Rotate</p>
        <p>• Right Mouse: Pan</p>
        <p>• Wheel: Zoom</p>
        <p>• Space: Toggle 45° cut</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 10000);
        camera.position.set(3500, 2000, 3500);
        camera.lookAt(0, 1200, 0);
        
        const renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5000, 5000, 3000);
        scene.add(dirLight);
        
        // Grid
        scene.add(new THREE.GridHelper(10000, 50, 0x444444, 0x333333));
        
        // Wall parameters
        const wallLength = 3000;
        const wallThickness = 150;
        const wallHeight = 2500;
        let has45Cut = false;
        let wallA, wallB;
        
        function createWall() {
            if (wallA) scene.remove(wallA);
            if (wallB) scene.remove(wallB);
        
            // ----- WALL A (Red) -----
            let geometryA, materialA;
            if (!has45Cut) {
                geometryA = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
            } else {
                const shapeA = new THREE.Shape();
                shapeA.moveTo(0, 0);
                shapeA.lineTo(wallLength, 0);
                shapeA.lineTo(wallLength - wallThickness, wallThickness);
                shapeA.lineTo(0, wallThickness);
                shapeA.closePath();
        
                // ✅ CHANGED: Extrude by thickness instead of height
                const extrudeA = { depth: wallThickness, bevelEnabled: false };
                geometryA = new THREE.ExtrudeGeometry(shapeA, extrudeA);
        
                // ✅ CHANGED: No rotateX, now rotate around Z to orient vertically
                geometryA.rotateX(Math.PI); // flip orientation if needed
                geometryA.rotateZ(Math.PI); 
            }
        
            materialA = new THREE.MeshStandardMaterial({
                color: 0xFF6B6B,
                roughness: 0.3,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
        
            wallA = new THREE.Mesh(geometryA, materialA);
            wallA.position.set(-wallLength / 2, wallHeight / 2, 0);
            scene.add(wallA);
        
            // ----- WALL B (Teal) -----
            let geometryB, materialB;
            if (!has45Cut) {
                geometryB = new THREE.BoxGeometry(wallLength, wallHeight, wallThickness);
            } else {
                const shapeB = new THREE.Shape();
                shapeB.moveTo(0, 0);
                shapeB.lineTo(wallLength, 0);
                shapeB.lineTo(wallLength, wallThickness);
                shapeB.lineTo(wallThickness, wallThickness);
                shapeB.closePath();
        
                // ✅ CHANGED: Extrude by thickness instead of height
                const extrudeB = { depth: wallThickness, bevelEnabled: false };
                geometryB = new THREE.ExtrudeGeometry(shapeB, extrudeB);
        
                // ✅ CHANGED: adjust rotation to meet 45° joint correctly
                geometryB.rotateY(Math.PI / 2);
            }
        
            materialB = new THREE.MeshStandardMaterial({
                color: 0x4ECDC4,
                roughness: 0.3,
                metalness: 0.1,
                side: THREE.DoubleSide
            });
        
            wallB = new THREE.Mesh(geometryB, materialB);
        
            if (!has45Cut) {
                wallB.position.set(wallLength/2 - wallThickness/2, wallHeight/2, wallThickness/2);
            } else {
                wallB.position.set(
                    wallLength/2 - wallThickness / Math.SQRT2,
                    wallHeight/2,
                    wallThickness / 2
                );
            }
        
            scene.add(wallB);
        
            const infoDiv = document.querySelector('.info');
            infoDiv.innerHTML = `
                <h3>Two Walls with ${has45Cut ? '45° Miter Joint' : 'Square Joint'}</h3>
                <p><strong>Wall A:</strong> Horizontal (Red) — ${has45Cut ? 'Right end 45° cut' : 'Square end'}</p>
                <p><strong>Wall B:</strong> Perpendicular (Teal) — ${has45Cut ? 'Left end 45° cut' : 'Square end'}</p>
                <p><strong>Press SPACE:</strong> Toggle 45° cuts</p>
            `;
        }
        
        document.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                has45Cut = !has45Cut;
                createWall();
            }
        });
        
        createWall();
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        </script>        
