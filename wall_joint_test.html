<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wall Joint Test - 45¬∞ Miter vs Butt Joint</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #info {
            margin-top: 10px;
            font-size: 12px;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls">
        <h3 style="margin-top: 0;">Wall Joint Test</h3>
        <div>Joint Type: <span id="jointType">butt_in</span></div>
        <button onclick="toggleJoint()">Toggle Joint Type</button>
        <button onclick="resetCamera()">Reset Camera</button>
        <div id="info">
            <p>üü¢ Green sphere = Joint point</p>
            <p>üî¥ Red wall = 1.6cm √ó 1.5cm √ó 0.15cm thick</p>
            <p>üîµ Blue wall = 0.8cm √ó 1.5cm √ó 0.15cm thick</p>
            <p>üìê Grid = 5cm √ó 5cm</p>
            <p>‚ö° 45¬∞ cut from outer‚Üíinner face</p>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // CSG utility functions (simplified version)
        class CSG {
            static fromMesh(mesh) {
                const geometry = mesh.geometry;
                const matrix = mesh.matrix;
                
                return {
                    geometry: geometry.clone().applyMatrix4(matrix),
                    material: mesh.material,
                    matrix: matrix
                };
            }

            static subtract(csgA, csgB) {
                // Simplified CSG subtraction
                // In production, use a proper CSG library
                return csgA;
            }

            static toMesh(csg, matrix, material) {
                const mesh = new THREE.Mesh(csg.geometry, csg.material);
                mesh.matrix.copy(matrix);
                mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
                return mesh;
            }
        }

        // Store demo instance globally for button handlers
        let demoInstance = null;

        class WallJointDemo {
            constructor() {
                this.container = document.getElementById('container');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.appendChild(this.renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;
                this.scene.add(directionalLight);

                // Controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;

                // Scaling
                this.scalingFactor = 0.01; // mm to meters
                this.modelOffset = { x: 0, z: 0 };

                // Trackers
                this.currentJointType = 'butt_in';
                this.walls = [];
                this.wallMeshes = [];

                // Create demo
                this.createDemo();
                this.setupEventListeners();
            }

            calculateModelCenter() {
                return { x: 0, y: 0, z: 0 }; // Origin-centered
            }

            createWall(wallData, jointType, joints = []) {
                const { start_x, start_y, end_x, end_y, height, thickness, id, color } = wallData;
                const scale = this.scalingFactor;

                // Snap function
                const snap = (val, precision = 0.01) => Math.round(val / precision) * precision;

                let startX = snap(start_x * scale);
                let startZ = snap(start_y * scale);
                let endX = snap(end_x * scale);
                let endZ = snap(end_y * scale);

                const dx = endX - startX;
                const dz = endZ - startZ;
                const wallLength = Math.hypot(dx, dz);
                const wallDirX = dx / wallLength;
                const wallDirZ = dz / wallLength;

                const modelCenter = this.calculateModelCenter();
                const wallMidX = (startX + endX) / 2;
                const wallMidZ = (startZ + endZ) / 2;
                const toCenterX = (modelCenter.x * scale) - wallMidX;
                const toCenterZ = (modelCenter.z * scale) - wallMidZ;

                // Check if wall is horizontal or vertical
                const isHorizontal = Math.abs(start_y - end_y) < 1e-6;
                const isVertical = Math.abs(start_x - end_x) < 1e-6;

                // Calculate wall normal
                let finalNormX, finalNormZ;
                if (isHorizontal) {
                    if (toCenterZ < 0) {
                        finalNormX = 0;
                        finalNormZ = -1;
                    } else {
                        finalNormX = 0;
                        finalNormZ = 1;
                    }
                } else if (isVertical) {
                    if (toCenterX < 0) {
                        finalNormX = -1;
                        finalNormZ = 0;
                    } else {
                        finalNormX = 1;
                        finalNormZ = 0;
                    }
                } else {
                    const normX = -dz / wallLength;
                    const normZ = dx / wallLength;
                    const dotProduct = normX * toCenterX + normZ * toCenterZ;
                    finalNormX = dotProduct < 0 ? -normX : normX;
                    finalNormZ = dotProduct < 0 ? -normZ : normZ;
                }

                // Wall dimensions
                const wallHeight = height * scale;
                const wallThickness = thickness * scale;
                let finalStartX = startX;
                let finalStartZ = startZ;
                let finalEndX = endX;
                let finalEndZ = endZ;

                // Check for 45¬∞ cuts
                let hasStart45 = false;
                let hasEnd45 = false;
                const nearlyEqual = (a, b) => Math.abs(a - b) < 0.001;
                
                // Add small gap for visibility in 45¬∞ cut mode
                let gapOffset = 0;

                if (joints.length) {
                    joints.forEach(j => {
                        if (j.joining_method === '45_cut' && (j.wall_1 === id || j.wall_2 === id)) {
                            // Add a gap so we can see the cut better
                            gapOffset = wallLength * 0.02; // 2% gap
                            
                            const otherWallId = j.wall_1 === id ? j.wall_2 : j.wall_1;
                            const otherWall = this.walls.find(w => w.id === otherWallId);

                            if (otherWall) {
                                const wall1StartX = finalStartX;
                                const wall1StartZ = finalStartZ;
                                const wall1EndX = finalEndX;
                                const wall1EndZ = finalEndZ;

                                const wall2StartX = otherWall.start_x * scale;
                                const wall2StartZ = otherWall.start_y * scale;
                                const wall2EndX = otherWall.end_x * scale;
                                const wall2EndZ = otherWall.end_y * scale;

                                // Calculate intersection
                                const intersection = this.calculateLineIntersection(
                                    wall1StartX, wall1StartZ, wall1EndX, wall1EndZ,
                                    wall2StartX, wall2StartZ, wall2EndX, wall2EndZ
                                );

                                if (intersection) {
                                    const jointX = intersection.x;
                                    const jointZ = intersection.z;

                                    if (nearlyEqual(jointX, finalStartX) && nearlyEqual(jointZ, finalStartZ)) {
                                        hasStart45 = true;
                                    }
                                    if (nearlyEqual(jointX, finalEndX) && nearlyEqual(jointZ, finalEndZ)) {
                                        hasEnd45 = true;
                                    }
                                }
                            }
                        }
                    });
                }

                // Create wall shape with actual 45¬∞ cuts
                const wallShape = new THREE.Shape();

                // Calculate cut depth (equal to wall thickness for 45¬∞ cut)
                const cutDepth = wallThickness;

                // Reduce wall length if there's a gap (for visibility of 45¬∞ cuts)
                let effectiveWallLength = wallLength - gapOffset;

                // Rectangle face (length X, height Y) - do not bake 45¬∞ into the face
                wallShape.moveTo(0, 0);
                wallShape.lineTo(0, wallHeight);
                wallShape.lineTo(effectiveWallLength, wallHeight);
                wallShape.lineTo(effectiveWallLength, 0);
                wallShape.lineTo(0, 0);

                // Extrude settings
                const extrudeSettings = {
                    depth: wallThickness,
                    bevelEnabled: false
                };

                const wallGeometry = new THREE.ExtrudeGeometry(wallShape, extrudeSettings);
                wallGeometry.computeVertexNormals();

                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: color || 0xffffff,
                    roughness: 0.5,
                    metalness: 0.7
                });

                let wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);

                // Apply 45¬∞ cuts if needed
                if (hasStart45 || hasEnd45) {
                    wallMesh = this.apply45DegreeCuts(wallMesh, hasStart45, hasEnd45, wallLength, wallHeight, wallThickness);
                }

                wallMesh.userData.isWall = true;
                wallMesh.castShadow = true;
                wallMesh.receiveShadow = true;

                // Rotate to match wall direction
                const finalDx = finalEndX - finalStartX;
                const finalDz = finalEndZ - finalStartZ;
                wallMesh.rotation.y = -Math.atan2(finalDz, finalDx);

                // Position the mesh
                const basePositionY = 0;
                wallMesh.position.set(
                    finalStartX + this.modelOffset.x,
                    basePositionY,
                    finalStartZ + this.modelOffset.z
                );

                // Add edge lines
                const edges = new THREE.EdgesGeometry(wallGeometry);
                const edgeLines = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0x000000 })
                );
                wallMesh.add(edgeLines);

                return wallMesh;
            }

            calculateLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
                const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

                if (Math.abs(denominator) < 1e-10) {
                    return null;
                }

                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;

                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                    return {
                        x: x1 + t * (x2 - x1),
                        z: y1 + t * (y2 - y1)
                    };
                }

                return null;
            }

            apply45DegreeCuts(wallMesh, hasStart45, hasEnd45, wallLength, wallHeight, wallThickness) {
    const pos = wallMesh.geometry.attributes.position;
    const arr = pos.array;
    const vcount = pos.count;

    // Work in local geometry space (before rotation), get actual extents
    wallMesh.geometry.computeBoundingBox();
    const bbox = wallMesh.geometry.boundingBox;
    const minX = bbox.min.x, maxX = bbox.max.x;
    const minZ = bbox.min.z, maxZ = bbox.max.z;

    const lenX = Math.max(1e-8, Math.abs(maxX - minX));
    const thickness = Math.max(1e-8, maxZ - minZ);
    const epsEndX = Math.max(1e-6 * lenX, 1e-5);

    for (let i = 0; i < vcount; i++) {
        const ix = i * 3;
        const x = arr[ix];
        const z = arr[ix + 2];

        // t=0 at OUTER face (z‚âàminZ), t=1 at INNER face (z‚âàmaxZ)
        let t = (z - minZ) / thickness;
        if (t < 0) t = 0; else if (t > 1) t = 1;

        // End cut: pull inner back along X up to thickness
        if (hasEnd45 && Math.abs(x - maxX) < epsEndX) {
            arr[ix] = x - t * thickness;
        }

        // Start cut: push inner forward along X up to thickness
        if (hasStart45 && Math.abs(x - minX) < epsEndX) {
            arr[ix] = x + t * thickness;
        }
    }

    pos.needsUpdate = true;
    wallMesh.geometry.computeVertexNormals();

    return wallMesh;
}


            createDemo() {
                // Clear existing walls
                this.wallMeshes.forEach(mesh => this.scene.remove(mesh));
                this.wallMeshes = [];

                // Define two perpendicular walls (compact size for better viewing)
                // Wall 1: Horizontal wall
                this.walls = [
                    {
                        id: 1,
                        start_x: -8,   // 0.8m to the left
                        start_y: 0,
                        end_x: 8,      // 0.8m to the right (1.6m total length)
                        end_y: 0,
                        height: 15,    // 1.5m tall
                        thickness: 1.5,  // 0.15m thick (15cm)
                        color: 0xff0000 // Red
                    },
                    {
                        id: 2,
                        start_x: 8,    // Start at END of red wall
                        start_y: 0,
                        end_x: 8,     // Keep X position
                        end_y: 8,     // 0.8m up
                        height: 15,    // 1.5m tall
                        thickness: 1.5,  // 0.15m thick (15cm)
                        color: 0x0000ff // Blue
                    }
                ];

                // Create joints based on current joint type
                const joints = [
                    {
                        id: 1,
                        wall_1: 1,
                        wall_2: 2,
                        joining_method: this.currentJointType
                    }
                ];

                // Create wall meshes
                this.walls.forEach(wall => {
                    const wallMesh = this.createWall(wall, this.currentJointType, joints);
                    this.scene.add(wallMesh);
                    this.wallMeshes.push(wallMesh);
                });

                // Add joint point marker (green sphere) at the intersection
                const centerMarker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.02, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                // Place marker at the joint point where walls meet (8, 0)
                centerMarker.position.set(
                    8 * this.scalingFactor,
                    0.1,
                    0
                );
                this.scene.add(centerMarker);

                // Add grid - match the scale (0.05m = 5cm grid)
                const gridHelper = new THREE.GridHelper(0.05, 50, 0x444444, 0x444444);
                this.scene.add(gridHelper);

                // Add axes - match scale (2cm axes)
                const axesHelper = new THREE.AxesHelper(0.02);
                this.scene.add(axesHelper);

                // Set camera to look at the joint point (end of red wall)
                this.camera.position.set(0.05, 0.05, 0.05);
                this.controls.target.set(0.008, 0.0075, 0);
                this.controls.update();

                // Update info display
                document.getElementById('jointType').textContent = this.currentJointType;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            toggleJoint() {
                this.currentJointType = this.currentJointType === 'butt_in' ? '45_cut' : 'butt_in';
                this.createDemo();
            }

            resetCamera() {
                this.camera.position.set(0.05, 0.05, 0.05);
                this.controls.target.set(0.008, 0.0075, 0);
                this.controls.update();
            }
        }

        // Initialize and store demo instance
        demoInstance = new WallJointDemo();
        
        // Make functions globally available for button handlers
        window.toggleJoint = () => {
            if (demoInstance) demoInstance.toggleJoint();
        };
        
        window.resetCamera = () => {
            if (demoInstance) demoInstance.resetCamera();
        };

        // Start animation loop
        demoInstance.animate();

        console.log('Wall Joint Demo initialized');
        console.log('Red wall: Horizontal wall');
        console.log('Blue wall: Vertical wall');
        console.log('Green sphere: Model center');
        console.log('Press "Toggle Joint Type" to switch between butt_in and 45_cut joints');
    </script>
</body>
</html>
